package tools.interviews.android.data.api

import android.util.Log
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import tools.interviews.android.data.InterviewDao
import tools.interviews.android.model.Interview
import tools.interviews.android.model.InterviewMethod
import tools.interviews.android.model.InterviewOutcome
import tools.interviews.android.model.InterviewStage
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException
import com.google.gson.Gson

class SyncService(
    private val interviewDao: InterviewDao,
    private val apiService: APIService = APIService.getInstance()
) {
    companion object {
        private const val TAG = "SyncService"
    }

    private val _isSyncing = MutableStateFlow(false)
    val isSyncing: StateFlow<Boolean> = _isSyncing.asStateFlow()

    private val _lastSyncDate = MutableStateFlow<LocalDateTime?>(null)
    val lastSyncDate: StateFlow<LocalDateTime?> = _lastSyncDate.asStateFlow()

    private val _syncError = MutableStateFlow<Exception?>(null)
    val syncError: StateFlow<Exception?> = _syncError.asStateFlow()

    private val gson = Gson()

    // Cache for API data (companies, stages, methods)
    private var cachedCompanies: List<APICompany> = emptyList()
    private var cachedStages: List<APIStage> = emptyList()
    private var cachedStageMethods: List<APIStageMethod> = emptyList()

    // MARK: - Sync All Data

    suspend fun syncAll() {
        _isSyncing.value = true
        _syncError.value = null

        try {
            // Fetch reference data first
            cachedCompanies = apiService.fetchCompanies()
            cachedStages = apiService.fetchStages()
            cachedStageMethods = apiService.fetchStageMethods()

            // Sync interviews
            syncInterviews()

            _lastSyncDate.value = LocalDateTime.now()
            Log.d(TAG, "Sync completed successfully")
        } catch (e: Exception) {
            _syncError.value = e
            Log.e(TAG, "Sync error: ${e.message}", e)
        }

        _isSyncing.value = false
    }

    // MARK: - Sync Interviews

    private suspend fun syncInterviews() {
        val apiInterviews = apiService.fetchInterviews(includePast = true)

        // Get all local interviews with server IDs (id > 0 means it came from server)
        // Note: Local-only interviews would have autoGenerated IDs, we need a way to distinguish
        // For now, we'll track server IDs separately or use a serverId field

        // Create a set of server interview IDs
        val serverInterviewIds = apiInterviews.map { it.id.toLong() }.toSet()

        // Process each API interview
        for (apiInterview in apiInterviews) {
            val interview = mapApiInterviewToLocal(apiInterview)

            // Check if interview exists locally
            val existing = interviewDao.getInterviewById(apiInterview.id.toLong())

            if (existing != null) {
                // Update existing interview
                interviewDao.update(interview)
                Log.d(TAG, "Updated interview: ${interview.jobTitle}")
            } else {
                // Insert new interview (use the server ID as local ID)
                interviewDao.insert(interview)
                Log.d(TAG, "Inserted interview: ${interview.jobTitle}")
            }
        }

        // Note: Deleting local interviews that don't exist on server would require
        // tracking which interviews came from the server vs created locally
        // For now, we don't delete to preserve local-only interviews
    }

    // MARK: - Push Interview to API

    suspend fun pushInterview(interview: Interview): APIInterview {
        val request = CreateInterviewRequest(
            stage = interview.stage.displayName,
            companyName = interview.companyName,
            clientCompany = interview.clientCompany,
            jobTitle = interview.jobTitle,
            jobPostingLink = extractJobListing(interview.metadataJSON),
            date = interview.interviewDate?.format(DateTimeFormatter.ISO_DATE_TIME),
            deadline = interview.deadline?.format(DateTimeFormatter.ISO_DATE_TIME),
            interviewer = interview.interviewer,
            locationType = when (interview.method) {
                InterviewMethod.VIDEO_CALL -> "link"
                InterviewMethod.PHONE_CALL -> "phone"
                InterviewMethod.IN_PERSON -> "in_person"
                null -> null
            },
            interviewLink = interview.link,
            notes = interview.notes
        )

        return apiService.createInterview(request)
    }

    suspend fun updateRemoteInterview(id: Int, interview: Interview): APIInterview {
        val request = UpdateInterviewRequest(
            outcome = interview.outcome.name.lowercase(),
            stage = interview.stage.displayName,
            date = interview.interviewDate?.format(DateTimeFormatter.ISO_DATE_TIME),
            deadline = interview.deadline?.format(DateTimeFormatter.ISO_DATE_TIME),
            interviewer = interview.interviewer,
            notes = interview.notes,
            link = interview.link
        )

        return apiService.updateInterview(id, request)
    }

    // MARK: - Mapping Helpers

    private fun mapApiInterviewToLocal(apiInterview: APIInterview): Interview {
        // Parse application date
        val applicationDate = parseDate(apiInterview.applicationDate) ?: LocalDate.now()

        // Parse interview date
        val interviewDate = apiInterview.date?.let { parseDateTime(it) }

        // Parse deadline
        val deadline = apiInterview.deadline?.let { parseDateTime(it) }

        // Map stage
        val stage = mapApiStageToLocal(apiInterview.stage?.stage)

        // Map method
        val method = mapApiMethodToLocal(apiInterview.stageMethod?.method)

        // Map outcome
        val outcome = mapApiOutcomeToLocal(apiInterview.outcome)

        // Build metadata JSON
        val metadataMap = mutableMapOf<String, Any>()
        apiInterview.metadata?.jobListing?.let { metadataMap["jobListing"] = it }
        apiInterview.metadata?.location?.let { metadataMap["location"] = it }
        metadataMap["applied"] = (apiInterview.stage?.stage == "Applied")
        val metadataJSON = gson.toJson(metadataMap)

        return Interview(
            id = apiInterview.id.toLong(),
            jobTitle = apiInterview.jobTitle,
            companyName = apiInterview.company.name,
            clientCompany = apiInterview.clientCompany,
            stage = stage,
            method = method,
            outcome = outcome,
            applicationDate = applicationDate,
            interviewDate = interviewDate,
            deadline = deadline,
            interviewer = apiInterview.interviewer,
            link = apiInterview.link,
            jobListing = apiInterview.metadata?.jobListing,
            notes = apiInterview.notes,
            metadataJSON = metadataJSON
        )
    }

    private fun mapApiStageToLocal(stageName: String?): InterviewStage {
        if (stageName == null) return InterviewStage.APPLIED

        return when (stageName.lowercase()) {
            "applied" -> InterviewStage.APPLIED
            "phone screen" -> InterviewStage.PHONE_SCREEN
            "first stage" -> InterviewStage.FIRST_STAGE
            "second stage" -> InterviewStage.SECOND_STAGE
            "third stage" -> InterviewStage.THIRD_STAGE
            "fourth stage" -> InterviewStage.FOURTH_STAGE
            "technical test" -> InterviewStage.TECHNICAL_TEST
            "technical interview" -> InterviewStage.TECHNICAL_INTERVIEW
            "final stage" -> InterviewStage.FINAL_STAGE
            "onsite" -> InterviewStage.ONSITE
            "offer" -> InterviewStage.OFFER
            else -> InterviewStage.APPLIED
        }
    }

    private fun mapApiMethodToLocal(methodName: String?): InterviewMethod? {
        if (methodName == null) return null

        return when (methodName.lowercase()) {
            "video call", "video" -> InterviewMethod.VIDEO_CALL
            "phone call", "phone" -> InterviewMethod.PHONE_CALL
            "in person", "in_person", "onsite" -> InterviewMethod.IN_PERSON
            else -> null
        }
    }

    private fun mapApiOutcomeToLocal(outcomeName: String?): InterviewOutcome {
        if (outcomeName == null) return InterviewOutcome.SCHEDULED

        return when (outcomeName.lowercase()) {
            "scheduled" -> InterviewOutcome.SCHEDULED
            "awaiting response", "awaiting_response", "pending" -> InterviewOutcome.AWAITING_RESPONSE
            "passed" -> InterviewOutcome.PASSED
            "rejected" -> InterviewOutcome.REJECTED
            "offer received", "offer_received" -> InterviewOutcome.OFFER_RECEIVED
            "offer accepted", "offer_accepted" -> InterviewOutcome.OFFER_ACCEPTED
            "offer declined", "offer_declined" -> InterviewOutcome.OFFER_DECLINED
            "withdrew", "withdrawn" -> InterviewOutcome.WITHDREW
            else -> InterviewOutcome.SCHEDULED
        }
    }

    private fun parseDate(dateString: String): LocalDate? {
        return try {
            // Try ISO date-time format first
            LocalDateTime.parse(dateString, DateTimeFormatter.ISO_DATE_TIME).toLocalDate()
        } catch (e: DateTimeParseException) {
            try {
                // Try ISO date format
                LocalDate.parse(dateString, DateTimeFormatter.ISO_DATE)
            } catch (e2: DateTimeParseException) {
                Log.w(TAG, "Failed to parse date: $dateString")
                null
            }
        }
    }

    private fun parseDateTime(dateString: String): LocalDateTime? {
        return try {
            LocalDateTime.parse(dateString, DateTimeFormatter.ISO_DATE_TIME)
        } catch (e: DateTimeParseException) {
            try {
                // If it's just a date, convert to start of day
                LocalDate.parse(dateString, DateTimeFormatter.ISO_DATE).atStartOfDay()
            } catch (e2: DateTimeParseException) {
                Log.w(TAG, "Failed to parse datetime: $dateString")
                null
            }
        }
    }

    private fun extractJobListing(metadataJSON: String?): String? {
        if (metadataJSON == null) return null

        return try {
            val map = gson.fromJson(metadataJSON, Map::class.java)
            map["jobListing"] as? String
        } catch (e: Exception) {
            null
        }
    }

    // MARK: - Getters for cached data

    fun getCachedCompanies(): List<APICompany> = cachedCompanies
    fun getCachedStages(): List<APIStage> = cachedStages
    fun getCachedStageMethods(): List<APIStageMethod> = cachedStageMethods
}